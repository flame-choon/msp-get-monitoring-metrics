name: Deploy to EC2 with ECR (OIDC)

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  EC2_HOST: ${{ secrets.EC2_HOST }}
  EC2_USER: ec2-user
  DEPLOY_PATH: /home/ec2-user/msp-ec2-monitor

# GitHub OIDC Provider를 사용하기 위한 권한 설정
permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-24.04-arm
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
        role-session-name: GitHubActions-ECR-Deploy
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        mask-password: 'true'

    - name: Set up Docker Buildx for ARM64
      uses: docker/setup-buildx-action@v3

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        DOCKER_BUILDKIT: 1
      run: |
        # Build specifically for ARM64 (Graviton)
        docker buildx build \
          --platform linux/arm64 \
          --push \
          --provenance=false \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          .

    - name: Deploy to EC2
      env:
        SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # SSH 키 설정
        mkdir -p ~/.ssh
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        # Known hosts 추가
        ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts
        
        # docker-compose.yml 파일 업데이트 및 전송
        cat > docker-compose.prod.yml << EOF
        
        services:
          ec2-monitor:
            image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            container_name: ec2-cross-account-monitor
            environment:
              SOURCE_ACCOUNT_ID: \${SOURCE_ACCOUNT_ID}
              TARGET_ACCOUNT_ID: \${TARGET_ACCOUNT_ID}
              ASSUME_ROLE_NAME: \${ASSUME_ROLE_NAME}
              SESSION_NAME: \${SESSION_NAME:-EC2ListingSession}
              AWS_REGION: \${AWS_REGION:-ap-northeast-2}
              LOG_LEVEL: \${LOG_LEVEL:-INFO}
            volumes:
              - ./logs:/app/logs
            restart: "no"
            network_mode: host
        EOF
        
        # 배포 디렉토리 생성
        ssh -i ~/.ssh/deploy_key $EC2_USER@$EC2_HOST "mkdir -p $DEPLOY_PATH"
        
        # docker-compose 파일 전송
        scp -i ~/.ssh/deploy_key docker-compose.prod.yml $EC2_USER@$EC2_HOST:$DEPLOY_PATH/
        scp -i ~/.ssh/deploy_key .env.example $EC2_USER@$EC2_HOST:$DEPLOY_PATH/
        
        # EC2에서 배포 실행
        ssh -i ~/.ssh/deploy_key $EC2_USER@$EC2_HOST << EOF
          cd $DEPLOY_PATH
          
          # .env 파일이 없으면 생성
          if [ ! -f .env ]; then
            cp .env.example .env
          fi
          
          # ECR 로그인 (EC2 인스턴스 Role 사용)
          export DOCKER_PASSWORD=\$(aws ecr get-login-password --region $AWS_REGION)
          echo "\$DOCKER_PASSWORD" | docker login --username AWS --password-stdin $ECR_REGISTRY > /dev/null 2>&1
          unset DOCKER_PASSWORD
          
          # 기존 컨테이너 중지 및 새 컨테이너 시작
          docker-compose -f docker-compose.prod.yml down || true
          docker-compose -f docker-compose.prod.yml pull
          docker-compose -f docker-compose.prod.yml up -d
          
          # 상태 확인
          sleep 5
          docker-compose -f docker-compose.prod.yml ps
          docker-compose -f docker-compose.prod.yml logs --tail=50
        EOF
        
        # SSH 키 제거
        rm -f ~/.ssh/deploy_key